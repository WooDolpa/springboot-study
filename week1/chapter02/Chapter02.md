# Chapter 02 
```
책 예제대로 최초 프로젝트 구성 후 프로젝트 실행시 다음과 같은 에러가 발생

Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.

datasource 관련된 url 설정과 관련된 에러이다.
Spring Data JPA 라이브러리가 추가되었기 때문에 자동으로 이에 관련된 설정을 넣어줘야 한다. 
```
###  ✅ H2
+ 인메모리 관계형 데이터베이스
+ 별도의 설치가 필요 없이 프로젝트 의존성만으로 관리 가능
+ 메모리에서 실행되기 때문에 애플리케이션을 재시작할 때마다 초기화된다는 점을 이용해 테스트 용도로 많이 사용
+ 책에서는 MariaDB 로 테스트하지만 다른 데이터베이스로 변경 가능

###  ✅ Spring Data JPA 소개
+ JPA(Java Persistence API)는 자바 언어를 통해서 데이터베이스와 같은 영속 계층을 처리하고자 하는 스펙
+ JPA를 이해하기 위해서는 ORM을 알아야한다.

###  ✅ ORM(Object-Relational-Mapping)
```
이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻

ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결

예시로 ORM 프레임워크를 사용하면 객체를 DB에 저장할때 Insert SQL을 직접 작성하는게 아니라 
객체를 마치 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장하면 됨

ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 DB에 전달해주는 것뿐만 아니라
다양한 패러다임의 불일치 문제들도 해결
따라서 객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 DB에 맞도록 모델링하면 됨

ORM 프레임워크에 둘의 매핑 방법만 알려주면 됨
ORM 프레임워크 중에 가장 많이 사용되는 Hibernate 프레임워크
개발자는 SQL에 노동에서 벗어나고 객체지향 애플리케이션 개발에 집중이 가능함
```
```
패러다임 불일치
객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다름
이 차이를 극복하기 위해 개발자는 너무 많은 시간과 코드를 소비

더 큰 문제는 정교한 객체 모델링을 할수록 패러다임의 불일치 문제가 더 커짐
문제가 커질수록 개발자가 소모해야 하는 비용도 더 늘어남
따라서 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해감
이 문제를 해결하고자 JPA 가 탄생했다.
JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와줌
```
###  ✅ JPA
```
과거 자바 진영은 엔터프라이즈 자바 빈즈(EJB)라는 기술 표준을 만들었는데
그안에는 엔티티 빈이라는 ORM 기술도 포함되어 있었지만 너무 복잡하고 기술 성숙도가 많이 떨어졌으며
자바 엔터프라이즈(J2EE) 애플리케이션 서버에서만 동작함
이때 하이버네이트라는 오픈소스 ORM 프레임워크가 등장했는데 EJB의 ORM 기술과 비교해서 가볍고
실용적인 데다 기술 성숙도도 높았다. 또한 자바 엔터프라이즈 애플리케이션 서버 없이도 동작해서
많은 개발자가 사용하기 시작함
결국 EJB 3.0에서 하이버네이트를 기반으로 새로운 ORM 기술 표준이 만들어 졌는데
이것이 바로 JPA이다.

Spring Data JPA <--> Hibernate <--> JDBC <--> DB

```

###  ✅ Spring Data JPA 설정 
```
spring.jpa.hibernate.ddl-auto=update  
--> 어플리케이션 실행 시 자동으로 DDL(create, alter, drop 등)을 생성할 것인지 결정하는 설정
설정값은 create, update, create-drop, validate
 - create : 기존 테이블 삭제 후 다시 생성 (Drop + Create)
 - create-drop : create 옵션 + 어플리케이션 종료시점에 Drop
 - update : 변경이 필요한 경우 alter로 변경되고 테이블이 없으면 create가 됨
 - validate : 엔티티와 테이블이 정상 매핑되었는지만 확인 

spring.jpa.properties.hibernate.format_sql=true
--> 실제 JPA의 구현체인 Hibernate가 동작하면서 발생하는 SQL을 포맷팅해서 출력함
실행되는 SQL의 가독성을 높여 줌

spring.jpa.show-sql=true
--> JPA 처리 시에 발생하는 SQL을 보여줄 것인지를 결정

Hibernate: 
    
    create table tb1_memo (
       mno bigint generated by default as identity,
        memo_text varchar(200) not null,
        primary key (mno)
    )

```

###  ✅ JpaRepository 인터페이스
+ Hibernate를 이용하기 위한 여러 API를 제공하는데 그중에서 개발자가 가장 많이 사용할 것이 JpaRepository 라는 인테페이스이다.
```
상속 구조
JpaRepository --> PagingAndSortRepository --> CurdRepository --> Repository
모든 JPA 관련 기능을 사용하고 싶을 때는 JpaRepository를 이용하며, JpaRepository 를 이용하는것이 무난함
```

| insert 작업 | save(엔티티 객체)                     |   
|-----------|----------------------------------|
| select 작업 | findById(키 타입), getOne(키타입)      |
| update 작업 | save(엔티티 객체)                     |
| delete 작업 | deleteById(키 타입), delete(엔티티 객체) |

#### JPA의 구현체가 메모리상(Entity Manager라는 존재가 엔티디들을 관리하는 방식) 에서 객체를 비교해 없다면 insert, 존재한다면 update를 동작하는 방식으로 동작


###  ✅ 패이징/정렬 처리하기
```
페이징 처리와 정렬은 전통적으로 SQL을 공부하는데 반드시 필요한 부분
특히 페이지 처리는 데이터베이스의 종류에 따라서 사용되는 기법이 다른 경우가 많아서 별도의 학습이 필요함
JPA는 내부적으로 이런 처리를 Dialect 라는 존재를 이용해 처리
```

###  ✅ Pageable 인터페이스
```
Pageable 인터페이스는 페이지 처리에 필요한 정보를 전달하는 용도의 타입
인터페이스이기 때문에 실제 객체를 생성할 때는 구현체인 PageRequest 클래스 사용
protected로 되어있어 static한 of()를 이용해서 처리
```
| of(int page, int size)                                           | 0부터 시작하는 페이지 번호와 개수(size), 정렬이 되지 않음   |  
|------------------------------------------------------------------|----------------------------------------|
| of(int page, int size, Sort.Direction direction, String...props) | 0부터 시작하는 페이지 번호와 개수, 정렬의 방향과 정렬 기준 필드들 |
| of(int page, int size, Sort sort)                                | 페이지 번호와 개수, 정렬 관련 정보                   |

###  ✅ 쿼리 메서드(Query Methods)
```
메서드의 이름 자체가 질의(query)문이 되는 흥미로운 기능
```

###  ✅ @Query 어노테이션
```
Spring Data JPA가 제공하는 쿼리 메서드는 조회 기능을 작성할 때 편리함을 제공하기는 하지만 
나중에 조인이나 복잡한 조건을 처리해야 하는 경우에는 'And, Or' 등이 사용되면서 불편함이 많다.
이럴때 @Query를 사용함
작성은 JPQL(Java Persistence Query Language)로 작성 객체지향 쿼리 라고 불리는 구문
```
+ 필요한 데이터만 선별적으로 추출 가능
+ 데이터베이스에 맞게 순수한 SQL(Native SQL)을 사용하는 기능
+ insert, update, delete와 같은 select가 아닌 DML 등을 처리하는 기능(@Modifying과 함께 사용)

``` java
@Query("select m from Memo m order by m.mno desc")
List<Memo> getListDesc();
```

###  ✅ @Query의 파라미터 바인딩
``` java
@Transactional
@Modifying
@Query("update Memo m set m.memoText = :memoText where m.mno = :mno")
int updateMemoText(@Param("mno") Long mno, @Param("memoText") String memoText);

@Transactional
@Modifying
@Query("update Memo m set m.memoText= :#{#param.memoText} where m.mno = :#{#param.mno}")
int updateMemoText(@Param("param") Memo memo);
```
+ '?1,?2' 와 1부터 시작하는 파라미터의 순서를 이용하는 방식
+ ':xxx' 와 같이 ':파라미터 이름'을 활용하는 방식
+ ':#{}'과 같이 자바 빈 스타일을 이용하는 방식

###  ✅ @Query와 페이징 처리
``` java
@Query(value= "select m from Memo m where m.mno > :mno",
        countQuery = "select count(m) from Memo m where m.mno > :mno")
Page<Memo> getListWithQuery(Long mno, Pageable pageable);
```
+ countQuery라는 속성을 적용해주고 Pageable 타입의 파라미터를 전달 

###  ✅ Object[] 리턴
+ JPQL을 이용할 때 경우에 따라서 Join이나 Group by 등을 이용하는 경우가 발생할때 적합
```java
@Query(value = "select m.mno, m.memoText, CURRENT_DATE from Memo m where m.mno > :mno",
        countQuery = "select count(m) from Memo m where m.mno > :mno")
Page<Object[]> getListWithQueryObject(Long mno, Pageable pageable);
```
###  ✅ Native SQL 처리
+ 데이터베이스 고유의 SQL 구문을 그대로 활용하는 것
+ JPA 자체가 데이터베이스에 독립적으로 구현이 가능하다는 장점을 잃어버리지만 복잡한 조인 구문을 처리하기 위해서 어쩔 수 없는 선택을 하는 경우에 사용
```java
@Query(value = "select * from memo where mno > 0", nativeQuery = true)
List<Object[]> getNativeResult();
```